<h2>C++基础知识复习</h2>

<hr>

`static`关键字作用

1. 隐藏：所有未加static前缀的全局变量和函数都具有全局可见性。（对函数而言，static作用只限于隐藏）
2. 保证变量内容的持久（全局生存区）
3. 默认初始化为0（与全局变量类似，都是放在静态数据区的）
4. 类中声明static，类的静态成员函数是属于整个类而非类的某个实例；也不可定义为虚函数（static是静态编译时绑定，而virtual是动态绑定的，多态实现的基本原理是每个带有virtual函数的类的【实例】要包含一个指针，指向虚函数表(vtbl)。static函数做为类函数，不与任何【实例】相关，自然无法实现多态了）静态数据成员是静态存储的，所以必须手动对它进行初始化。 

<hr>

4种cast转换

1. `static_cast<>()`跟C中的转化类似，允许执行C++中内置的基本数据类型之间的转换，但不能进行无关类型指针之间的转换（如非基类和子类之间，int* 转向 char*这种都是禁止的）
2. `const_cast<>()`把本来是const的数据变成不是const的或者相反
3. `reinterpret_cast<>()`重新解释，也就是直接对二进制进行重新解释，基本不要使用
4. `dynamic_cast`运行时处理的，只用于对象的指针和引用，不能对内置的基本数据类型进行转换。

在类的转换时，在类层次间进行上行转换时，`dynamic_cast`和`static_cast`的效果是一样的。在进行下行转换 时，`dynamic_cast`具有类型检查的功能，比`static_cast`更安全。向上转换即为指向子类对象的向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败，如果是指针则为空指针，如果为引用则抛出异常。

而且基类中一定要有虚函数，否则编译失败：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。 

<hr>

指针和引用的区别

1. 引用必须初始化，而指针可以不初始化。
2. 引用不能为空，指针可以为空
3. 引用不能更换目标

引用优点：

使用const reference参数作为只读形参，这种情况下既可以避免参数拷贝还可以获得与传值参数一样的调用方式。此外，在重载运算符的时候，使用引用型返回值可以获得跟该操作符原来语法相同的调用方式，保持了操作符语义的一致性

性能两者是一致的

<hr>

智能指针

智能指针的出现实际上就是为了可以方便的控制对象的生命期，在智能指针中，一个对象什么时候和在什么条件下要被析构或者是删除是受智能指针本身决定的，用户并不需要管理。

`shared_ptr`：`shared_ptr`与`unique_ptr`类似。要创建`shared_ptr`对象，可以使用`make_shared()`函数，可以有多个`shared_ptr`实例可以指向同一块动态分配的内存，当最后一个引用对象离开其作用域时，才会释放这块内存。

`shared_ptr`与`unique_ptr`内部实现机理有区别，前者内部使用两个指针，一个指针用于管理实际的指针，另外一个指针指向一个”控制块“，其中记录了哪些对象共同管理同一个指针。这是在初始化完成的，所以如果单独初始化两个对象，尽管管理的是同一块内存，它们各自的”控制块“没有互相记录的。所以，上面的问题就出现了。但是如果是使用复制构造函数还有赋值运算时，“控制块”会同步更新的，这样就达到了引用计数的目的。使用`make_shared`就不会出现上面的问题，所以要推荐使用。

`unique_ptr`：其用于不能被多个实例共享的内存管理。这就是说，仅有一个实例拥有内存所有权。尽量使用`make_unique`方式进行创建

`weak_ptr`：`shared_ptr`可以实现多个对象共享同一块内存，当最后一个对象离开其作用域时，这块内存被释放。但是仍然有可能出现内存无法被释放的情况，联想一下“死锁”现象（`shared_ptr`被循环引用）

这时候`weak_ptr`应运而生。`weak_ptr`可以包含由`shared_ptr`所管理的内存的引用。但是它仅仅是旁观者，并不是所有者。那就是`weak_ptr`不拥有这块内存，当然不会计数，也不会阻止`shared_ptr`释放其内存。但是它可以通过lock()方法返回一个`shared_ptr`对象，从而访问这块内存。这样我们可以用`weak_ptr`来解决的“循环引用”问题

<hr>

数组与指针

首先，数组名不是常量指针，从两方面： 
1. 类型方面，数组的类型是type[size]，和常量指针类型type* const不同 
2. 使用方面，sizeof(数组名)等于数组所有元素的大小，而不是sizeof(指针)；对数组取地址，得到的指针进行加减，增减字节数是sizeof(数组)；你可以用字符串字面量初始化一个字符数组，但是不能用常量指针来初始化一个字符数组。

1. 数组名的类型就是数组类型type[size] （参见Array declaration） 
对数组取址，得到的类型是指向数组的指针type(*)[size] （参见Member access operators） 
2. 数组名在大部分情况下会隐式转换为首元素指针右值，除了（参见 Implicit conversions）

sizeof运算的时候
取址的时候
用字符串字面量初始化字符数组的时候

<hr>

构造函数调用虚函数会出现什么情况，析构函数为什么要虚函数？

虚拟函数调用只需要“部分的”信息，即只需要知道函数接口，而不需要对象的具体类型。但是构建一个对象，却必须知道具体的类型信息。如果你调用一个虚拟构造函数，编译器怎么知道你想构建是继承树上的哪种类型呢？所以这在逻辑上是一个悖论。

析构函数只负责回收当前层次。基类析构基类成员，派生类析构派生类成员。基类的析构函数没法回收派生类的全部资源

```cpp
Base *b = new Derived();
// use b
delete b; // Here's the problem!如果Derived析构函数中有内存释放等操作就出现泄漏
```

<hr>

C++如何实现虚函数的机制？虚表保存在哪？虚表的大小？虚表大小和虚函数数量是否有关？

都用虚函数表vtable，表的第一个位置放的是跟运行时有关的东西（RTTI），然后就是根据你类中虚函数的声明次序来存放。虚表不一定保存在类头部，标准没有规定，绝大部分编译器实现如此

虚表是每个类一个虚表，然后每个实例有一个虚表指针，如果是基类指针指向派生类，运行时指针将会取得当前指向的内存对象（也就是派生类）的虚表，然后找到正确的函数版本入口地址

<hr>

类的内存布局是什么样的？考虑有虚函数、多继承、虚继承几种情况

空类占用为1，标准规定完整对象的大小为必须是正数，因为空的类或结构体同样可以被实例化，如果定义对空的类或者结构体取sizeof()的值为0，那么该空的类或结构体实例化出很多实例时，在内存地址上就不能区分该类实例化出的实例

类只有成员变量占用内存**（静态成员不占类内部内存，函数不占内存）**。如果有虚函数，每个类对象都会有一个虚函数指针Vptr（占用一个指针大小的内存），vptr指向一个虚函数表，表里面记录了各项标记virtual的函数，子类如果覆盖父类虚函数，对应虚表位置的虚函数会被子类的替换。如果是虚继承，还会有虚基类表记录当前对象相对虚基类的偏移，以及一个虚基类指针指向这个虚基类表。

虚表在编译完成时大小与布局就被决定了，加载时其内存位置也就被确定了。

单继承一个或多个类只有一个虚表一个虚指针

普通多继承会有基类的个数个虚表，基类的个数个虚指针。派生类自己独有的虚函数可能会放在第一个虚表的最后面

单个虚继承会有两个虚表（看情况）以及一个虚基类表，两个虚指针（这个可能与我们想象中的不一样，一个指向自己独有的虚函数的虚表，一个指向覆盖基类虚函数的虚表）以及一个虚基类指针与虚基类表 注意：如果派生类自己的虚函数与基类完全相同，可能只有一个虚表，一个虚指针

菱形多虚继承会有基类的个数个虚指针以及虚表（看情况，第3条有提到），有几个虚继承就有几个虚基类指针以及虚基类表

<hr>

多态除了用virtual这种动态多态，有没有了解过静态多态？有哪几种多态？

静态动态(编译时多态):主要通过函数和运算符重载来实现;

动态动态(运行时多态):主要通过继承和虚函数来实现.

<hr>

模版实例化是什么意思？发生在什么阶段？为什么发生在这个阶段？

当首次为每个类型调用函数模板时，编译器会创建一个实例化。每个实例化是专用于该类型的模板化函数版本。每次将该函数用于该类型时，此实例化都将调用。如果有几个相同的实例化，即使在不同的模块中，也只有该实例化的一个副本将在可执行文件中结束。

<hr>

有没有办法把模版类实现放在cpp文件里？

使用外名模板，它的作用在于使得模板代码可依照C/C++语言习惯，将模板声明和实现分开分别放到.h和.cpp文件中，并且可以减少冗长的模板编译时间（否则同一模板实例需要在不同编译单元中分别实例化）（但是在C++11以后放弃了）

C++中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道，模板类中使用模板类型的对象的所占用的空间的大小的。只有模板被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。这也就是模板类为什么只是称之为模板，而不是泛型的缘故。

<hr>

override和overload的区别

重载与重写的区别：主要注意这个：如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏

<hr>

C++为什么要增加override关键字？为了解决什么问题？

如果派生类在虚函数声明时使用了override描述符，那么该函数必须覆盖其基类中的同名函数，否则代码将无法通过编译。

如果派生类里面是像覆盖虚函数 就加上关键字override 这样编译器可以辅助检查是不是正确覆盖，如果没加这个关键字 也没什么严重的error 只是少了编译器检查的安全性

<hr>

有没有分析过`push_back` n次平均复杂度？

假定有 n 个元素,倍增因子为 m。那么完成这 n 个元素往一个 vector 中的`push_back`操作，需要重新分配内存的次数大约为 logm(n)，第 i 次重新分配将会导致复制 m^i (也就是当前的vector.size() 大小)个旧空间中元素，因此 n 次 push_back操作所花费的总时间约为 n*m/(m - 1):

<hr>

vector 的 size 和 capacity 的区别

size是当前vector容器真实占用的大小，也就是容器当前拥有多少个容器。
capacity是指在发生realloc前能允许的最大元素数，即预分配的内存空间。

<hr>

vector 与数组区别是什么，vector如何动态分配空间

空间灵活性，可以动态分配内存；内存空间只会增长，不会减小，援引C++ Primer：为了支持快速的随机访问，vector容器的元素以连续方式存放，每一个元素都紧挨着前一个元素存储。如果size超过的capacity，就要扩展（把原来地方的数据拷贝构造到2倍于此大小的capacity位置，析构原来位置的数据）

<hr>

介绍一下`allocator`类

allocator类

目的：把内存分配和对象构造分离开来（new是把两个整合在一起，对于构造单个对象有利，对于动态内存，按需构造来说浪费性能），分配得到的内存是原始的，未经过构造的（所以直接使用未构造的内存是严重错误！Ub）；该类定义在<memory>头文件中。

使用时要先调用`a.allocate(n)`申请n个T类型内存，然后`a.construct(p,args)`进行构造，在析构时使用`a.destroy(p)`，`a.deallocate(p,n)`

```cpp
allocator<string> alloc;
auto const p = alloc.allocate(n);//分配n个未初始化的string
auto q = p;
alloc.construct(q++,10,'c');//q指向最后构造元素之后的位置
cout << *p << endl;//*p为cccccccccc，输出*q是未定义的
while(q != p)
    alloc.destroy(--q);//释放我们实际构造出来的string（也只能对实际构造出来的对象进行destroy）
alloc.deallocate(p,n);//p不可为空，n必须相同
```

<hr>

STL中`resize`和`reserve`的区别

改变容器的大小，resize()（不适用于array）注意：不会改变容器的占用的内存大小，只改变元素的数目

```cpp
list<int> ilist(10,42);//10个int，每个值为42
ilist.resize(15);//增加5个值为0的元素加在末尾
ilist.resize(25,-1);//增加10个值为-1的元素加在末尾
ilist.resize(5);//从链表末尾删除20个元素
```

`c.reserve(n)`：分配至少能容纳n个元素的内存空间，如果小于当前容量，reserve什么都不做，而不会退回空间

<hr>

可变函数模板

展开可变模版参数函数的方法一般有两种：一种是通过递归函数来展开参数包（需要提供一个参数包展开的函数和一个递归终止函数），另外一种是通过逗号表达式来展开参数包。

```cpp
//递归终止函数
void print()
{
   cout << "empty" << endl;
}
//展开函数
template <class T, class ...Args>
void print(T head, Args... rest)
{
   cout << "parameter " << head << endl;
   print(rest...);
}

//逗号表达式
template <class T>
void printarg(T t)
{
   cout << t << endl;
}

template <class ...Args>
void expand(Args... args)
{
   int arr[] = {(printarg(args), 0)...};
}

expand(1,2,3,4);
```

<hr>

移动语义和右值引用

下面的代码如果都是使用拷贝构造函数，则整体开销会非常惊人，也就是构造自己的时候返回的东西传入到vecStr中需要一个拷贝构造函数进行一个额外的拷贝，然后释放掉自己的原来的资源，这样带来一个比较大的性能开销

```cpp
vector<MyString> vecStr;
vecStr.reserve(1000); //先分配好1000个空间
for(int i=0;i<1000;i++){
    vecStr.push_back(MyString("hello"));
}
```

使用`std::move()`就能够直接使用这个临时值的资源，避免了一个额外的性能开销，交出了资源之后就不要使用临时值了，会产生UB

如果与模板混合

```cpp
template<typename T>
void f( T&& param){
    
}
f(10);  //10是右值
int x = 10; //
f(x); //x是左值，推导得到int &，引发引用折叠
```