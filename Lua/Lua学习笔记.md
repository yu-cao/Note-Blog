## Lua 学习笔记

Lua作为一门动态语言，变量没有类型，但是值是有类型的，所有的值只能携带自己的类型

Lua中值是一等公民，所有的值都能被存储到变量中，作为参数传入函数，或者作为返回值返回

8种基本类型：

+ `nil`：通常表示某个变量是否有效
+ `boolean`：true/false。false和nil会使得条件判断为false，其余的值都是true
+ `number`：int和浮点数。有两个内部类型，int和float；尽管对何时使用某种类型有标准，但是它们是可以内部转换的，一般可以忽略这个问题。默认是64位int/float
+ `string`：不可变的字节序列。是以8位结算的，字符串可以包含任何8位的值，包括`\0`。Lua没有假设字符串中的内容
+ `function`：Lua可以调用（和操作）用Lua编写的函数和用C编写的函数。两者都由`function`表示。
+ `userdata`：允许任意C数据存储在Lua变量中。 userdata值表示原始内存块。有两种userdata：full userdata（一个由Lua管理的内存块的对象）和light userdata（只是一个C指针值）。Userdata在Lua中没有预定义的操作，除非是赋值和identity test。通过使用`metatable`，程序员可以定义对于full userdata值的操作。只能通过C API在Lua中创建或修改Userdata值。这保证了主机程序拥有的数据的完整性。
+ `thread`：表示独立的执行线程，它用于实现协程。Lua线程与操作系统线程无关。Lua支持所有系统上的协同程序，甚至是那些本身不支持线程的协同程序。
+ `table`：用来实现关联数组，不仅可以包含数字作为索引的数组，也可以包含除nil和NaN外的任何值。表可以是异构的；也就是说，它们可以包含所有类型的值（除了nil）。值为nil的任何键都不被视为表的一部分。相反，任何不属于表的键都具有关联值nil。

表是Lua中唯一的数据结构机制：它们可用于表示普通数组，链表，符号表，集合，record，图，树等。为了表示记录，Lua使用字段名称作为索引。该语言通过提供`a.name`作为`a["name"]`的语法糖来支持此表示

与索引一样，table字段的值可以是任何类型。特别是，因为函数是第一类值，所以table字段可以包含函数。因此，table也可以带有方法

表的索引遵循语言中原始相等的定义。表达式a[i]和a[j]表示相同的表元素当且仅当i和j是原始相等时（即equal without metamethods）。特别地，具有整数值的浮点数等于它们各自的整数（例如，1.0 == 1）。为避免歧义，任何具有用作键的整数值的浮点数都将转换为其各自的整数。例如，如果你写一个[2.0] = true，插入表中的实际key将是整数2，value为true.（另一方面，`2`和`"2"`是不同的Lua值，因此表示不同的表项。）

表，函数，线程和（full）用户数据值是对象：**变量实际上不包含这些值，只是对它们的引用。**赋值，参数传递和函数返回总是操纵对这些值的**引用**

库函数`type`返回一个字符串来描述一个给定值的类型

### 环境与全局环境

对于自由名称（没有绑定到任何声明上的名称）`var`的任何引用语法都会被翻译为`_ENV.var`。此外，每个chunk都会在名为`_ENV`的外部局部变量范围内编译。因此`_ENV`在chunk内部自身并不是一个自由的名称

尽管存在这个外部`_ENV`变量和自由名称的翻译，但是事实上`_ENV`完全就是一个普通的名称。特别地，你可以用那个名字定义一个新的变量或参数。每个对于自由名称的引用都是用在该点可见的`_ENV`，这遵循Lua的usual visibility rule

用作_ENV值的任何table都称为环境（environment）

Lua保持这一个特别的环境，称为全局环境。这个值保持在一个C注册表中的特别的索引处。在Lua中，全局变量`_G`被初始化为相同的值（`_G`不会被内部使用）

当Lua加载一个块时，其`_ENV` upvalue的默认值是全局环境。因此，默认情况下，Lua代码中的自由名称是指全局环境中的条目（因此，它们也称为全局变量）。此外，所有标准库都加载到全局环境中，并且一些功能在该全局环境中运行。我们可以使用load（或loadfile）来加载具有不同环境的块。（在C中，您必须加载块（chunk），然后更改其第一个upvalue的值）

### 错误处理

Lua是一种嵌入式的拓展语言，所有的Lua操作都是从宿主程序中的C代码开始，从Lua库中调用另一个函数（当使用Lua standalone时，lua应用程序就是主程序），每当遇到错误时，控制权将会给回到host，以采取相应措施进行处理。

Lua代码可以通过调用错误函数显式生成错误。如果需要在Lua中捕获错误，可以使用`pcall`或`xpcall`在受保护模式下调用给定函数。

每当出现错误时，都会传播错误对象（也称为错误消息），其中包含有关错误的信息。 Lua本身只生成错误对象（这个对象是字符串），但程序可能会生成带有值的错误作为错误对象。由Lua程序或其主机来处理这样的错误对象。

当你使用`xpcall`或者`lua_pcall`时，可以在出现错误时提供一个message handler。这个函数将会与原始的错误一起被调用并且返回一个新的错误对象。它将会被调用在stack展开之前，以便它可以收集有关错误的更多信息，例如通过检查堆栈并创建堆栈回溯。此消息处理程序仍受protected call保护；所以，消息处理程序中的错误将再次调用消息处理程序。如果这个循环持续太长时间，Lua会打破它并返回一个适当的消息。 （仅针对常规运行时错误调用消息处理程序。在运行终结器时，不会调用内存分配错误或错误。）

### Metatables和Metamethods（元表和元方法）

每个在Lua中的值都可以有一个metatable，这是一个典型的Lua中的table，用来定义在特定的操作下原始值的行为。我们可以在其元表中设置特定字段来更改操作行为的几个方面。例如，当非数字值是加法的操作数时，Lua检查值metatable的字段“__add”中的函数。如果找到一个，Lua会调用此函数来执行添加。

metatable中每个事件的key是一个字符串，其事件名称前缀为两个下划线；相应的值称为metamethods。在前面的示例中，键是“__add”，metamethod是执行添加的函数。除非另有说明，否则metamethods应该是function value

我们可以查询metatable中的任何值，当我们是用getmetatable函数时。Luau的查询metamethods在metatables使用原始访问的方式。所以，如果要检索事件`ev`在对象`o`中，Lua将执行与以下代码等价的操作：

```lua
rawget(getmetatable(o) or {}, "__ev")
```

可以使用`setmetatable`函数替换表的metatable。您无法从Lua代码更改其他类型的metatable（除非使用调试库）;应该使用C API进行修改

表和完整的userdata具有单独的metatable（尽管多个表和userdata可以共享其metatable）。所有其他类型的值每种类型共享一个metatable；也就是说，所有数字都有一个metatable，所有字符串都有一个metatable... 默认情况下，一个值没有metatable，但是字符串库为字符串类型设置了metatable

metatable控制对象在算术运算，按位运算，顺序比较，串联，长度运算，调用和索引中的行为方式。 metatable还可以定义当userdata或table被gc时要调用的函数

对于一元运算符，metamethod被计算并与一个虚拟的第二个操作数同时调用，等价于第一个操作数。这个额外的操作数只是为了简化Lua的内部（通过使这些操作符像二进制操作一样），并且可能在将来的版本中被删除。 （对于大多数用途，这个额外的操作数是无关紧要的。）

接下来给出由元表控制的事件的详细列表。每个操作由其相应的键标识：

+ `__add`：加法（+）操作。如果添加的任何操作数不是数字（也不是对数字强制的字符串），Lua将尝试调用metamethod。首先，Lua将检查第一个操作数（即使它是有效的）。如果该操作数没有为__add定义元方法，那么Lua将检查第二个操作数。如果Lua可以找到一个metamethod，它会将两个操作数作为参数调用metamethod，并且调用的结果（调整为一个值）是操作的结果。否则，它会引发错误。
+ `__sub`：减法操作，行为基本类似
+ `__mul`
+ `__div`
+ `__mod`
+ `__pow`
+ `__unm`：否定操作（即一元的`-`）
+ `__idiv`：取下界的除法操作（`//`）
+ `__band`：按位AND操作。如果任何两个操作数都不是整数或者可以被转换为整数的数，将会尝试metamethod
+ `__bor`：按位OR
+ `__bxor`: 按位XOR
+ `__bnot`: 按位NOT
+ `__shl`: 左移（<<）
+ `__shr`: 右移（>>）
+ `__concat`：连接（..）操作。类似于加法运算的行为，除了如果任何操作数既不是字符串也不是数字（对于字符串总是可强制的），Lua将尝试metamethod。
+ `__len`：长度（＃）操作。如果对象不是字符串，Lua将尝试其metamethod。如果存在metamethod方法，Lua将该对象作为参数调用，并且调用的结果（始终调整为一个值）是操作的结果。如果没有metamethod但对象是表，则Lua使用表长度操作。否则，Lua会引发错误。
+ `__eq`：等于（==）操作。类似于加法运算的行为，除了Lua将仅在被比较的值既是表或两个完整用户数据并且它们不是原始相等时尝试元方法。调用的结果总是转换为布尔值。
+ `__lt`：小于（<）操作。行为类似于加法运算，除了Lua只在被比较的值既不是两个数字也不是两个字符串时尝试元方法。调用的结果总是转换为布尔值。
+ `__le`：小于等于（<=）不像其他操作，这个操作可以使用两个不同的事件。首先，Lua在两个操作数中查找`__le`元方法，就像在`less`操作中一样。如果它找不到这样的元方法，那么它将尝试`__lt`元方法，(将 小于等于 变成 大于然后取反 执行)，结果总是bool
+ `index`：索引访问操作`table[key]`。当`table`不是表或表中没有键时，会发生此事件。 metame方法在表格中查找。尽管有这个名字，这个事件的元方法可以是函数或表。如果它是一个函数，则使用table和key作为参数调用它，并且调用的结果（调整为一个值）是操作的结果。如果是表，则最终结果是使用键索引此表的结果。 （这种索引是常规的，而不是原始的，因此可以触发另一种元方法。）
+ `__newindex`：索引分配表`[key] = value`。与索引事件一样，当`table`不是表或表中没有`key`时，会发生此事件，metamethed会在`table`中查找。与索引一样，此事件的元方法可以是函数或表。如果它是一个函数，则使用table，key和value作为参数调用它。如果它是一个表，Lua会使用相同的键和值对此表进行索引分配。只要有`__newindex`元方法，Lua就不会执行原始赋值。（如有必要，metamethod本身可以调用rawset来完成赋值。）
+ `__call`：调用操作`func(args)`。当Lua尝试调用非函数值（即`func`不是函数）时，会发生此事件。metamethod将会在`func`中被查找。如果存在，则使用func作为其第一个参数调用元方法，然后调用原始调用的参数（args）。调用的所有结果都是操作的结果。（这是唯一允许多个结果的元方法）

在将其设置为某个对象的元表之前，将所有需要的元方法添加到表中是一种很好的做法。特别是，`__ gc`元方法仅在遵循此顺序时才有效

因为元表是常规表，所以它们可以包含任意字段，而不仅仅是上面定义的事件名称。标准库中的一些函数（例如，tostring）使用元表中的其他字段用于它们自己的目的

### Garbage Collection

Lua执行自动内存管理。这意味着不必担心为新对象分配内存或在不再需要对象时释放它。 Lua通过运行垃圾收集器来自动管理内存，以收集所有死对象（即不再可从Lua访问的对象）。 Lua使用的所有内存都受自动管理：字符串，表，用户数据，函数，线程，内部结构等。

Lua实现了一个增量的标记和扫描收集器。它使用两个数字来控制其垃圾收集周期：垃圾收集器暂停和垃圾收集器步骤倍增器。两者都使用百分点作为单位（例如，值100表示​​内部值为1）。

垃圾收集器暂停控制收集器在开始新循环之前等待的时间。较大的值使收集器不那么具有攻击性。小于100的值意味着收集器不会等待开始新的循环。值200表示收集器在开始新循环之前等待使用的总内存加倍。

垃圾收集器步骤乘法器控制收集器相对于内存分配的相对速度。较大的值会使收集器更具侵略性，但也会增加每个增量步骤的大小。不应该使用小于100的值，因为它们会使收集器太慢并且可能导致收集器永远不会完成一个循环。默认值为200，这意味着收集器以“两倍”的内存分配速度运行。

如果将步长乘数设置为一个非常大的数字（大于程序可能使用的最大字节数的10％），则收集器的行为就像一个stop-the-world收集器。如果然后将暂停设置为200，则收集器的行为与旧的Lua版本相同，每次Lua将其内存使用量增加一倍时执行完整集合。

我们可以通过在C中调用`lua_gc`或在Lua中调用`collectgarbage`来更改这些数字。还可以使用这些函数直接控制收集器（例如，停止并重新启动）。

#### Garbage-Collection Metamethods

可以为表设置垃圾收集器元方法，并使用C API为完整用户数据设置。这些元方法也称为终结器（finalizers）。终结器允许您协调Lua的垃圾收集与外部资源管理（例如关闭文件，网络或数据库连接，或释放您自己的内存）

对于要在收集时完成的对象（表或用户数据），必须将其标记为finalization。在设置metatable并且metatable具有由字符串`"__gc"`索引的字段时，标记对象为finalization，。请注意，如果设置不带`__gc`字段的metatable，然后在metatable中创建该字段，则不会标记该对象以进行finalization。

当标记的对象变为垃圾时，垃圾收集器不会立即收集它。相反，Lua把它放在一个列表中。收集完成后，Lua会查看该列表。对于列表中的每个对象，它检查对象的`__gc`元方法：如果它是一个函数，Lua将该对象作为其单个参数调用它;如果metamethod不是函数，Lua就会忽略它。

在每个垃圾收集周期结束时，对象的终结器按照与该周期中收集的对象被标记为完成的相反顺序进行调用；也就是说，要调用的第一个终结器是与程序中最后标记的对象相关联的终结器。每个终结器的执行可以在执行常规代码期间的任何时刻发生。

因为正在收集的对象仍然必须由终结器使用，所以该对象（以及只能通过它访问的其他对象）必须由Lua复活（resurrected）。通常，这种复活是暂时的，并且对象的内存会在下一个GC周期中释放。但是，如果终结器将对象存储在某个全局位置（例如，全局变量），则复活是永久性的。此外，如果终结器再次标记最终化的终结对象，则终结器将会调用在下一个对象已经无法访问的周期中再次调用。在任何情况下，对象内存的释放只有在当对象是无法访问且没有标记为finalization的GC cycle中

当你关闭一个状态（参见lua_close）时，Lua按照标记的相反顺序调用标记为完成的所有对象的终结符。如果任何终结器在该阶段标记要收集的对象，则这些标记无效

#### Weak Tables

弱表是一个表，其元素是弱引用。垃圾收集器忽略弱引用。换句话说，如果对对象的唯一引用是弱引用，则垃圾收集器将收集该对象。

弱表可以具有弱键，弱值或两者。具有弱值的表允许收集其值，但会阻止其键的收集。具有弱键和弱值的表允许收集键和值。在任何情况下，如果收集了key或value，则从表中删除整个对。表的weakness由其metatable的`__mode`字段控制。如果`__mode`字段是包含字符`'k'`的字符串，则表中的键很弱。如果`__mode`包含`'v'`，则表中的值很弱。

具有弱键和强值的表也称为`ephemeron table`。在ephemeron表中，只有在其key可访问时，才认为该值是reachable。特别是，如果对键的唯一引用通过其值，则删除该对。

表的weakness的任何变化仅在下一个收集周期生效。特别是，如果您将weakness更改为一种更强的模式，Lua可能会在更改生效之前从该表中收集一些项目。

仅从弱表中删除具有显式构造的对象。诸如数字和轻C函数之类的值不受垃圾收集的影响，因此不会从弱表中删除（除非收集它们的相关值）。虽然字符串可以进行垃圾回收，但它们没有明确的构造，因此不会从弱表中删除。

objects being finalized and objects accessible only through objects being finalized

复活的对象（即，最终确定的对象和仅通过最终确定的对象可访问的对象）在弱表中具有特殊行为。它们在运行finalizers之前就把weak value删除，但它们被移除weak key只有在运行为它们的finalizer的下一个collection中进行，那时这些object实际上已经被释放。此行为允许finalizer通过弱表访问与对象关联的属性。

如果在收集周期中复活的对象中存在弱表，则在下一个周期之前可能无法正确清除它。

### Coroutines

Lua支持协程。Lua中的协程代表一个独立的执行线程。但是，与多线程系统中的线程不同，协程只通过显式调用yield函数来暂停其执行。

您可以通过调用`coroutine.create`来创建一个协程。它唯一的论点是一个函数，它是协程的主要功能。create函数只创建一个新的协程并返回一个句柄（一个类型为thread的对象）;它没有启动协程。

您可以通过调用`coroutine.resume`来执行协程。当你第一次调用`coroutine.resume`，作为第一个参数传递`coroutine.create`返回的一个线程时，协程通过调用它的main函数来启动它的执行。传递给`coroutine.resume`的额外参数作为参数传递给该函数。协程开始运行后，它会一直运行直到它终止或yield。

协程可以通过两种方式终止其执行：通常，当其主函数返回时（显式或隐式地，在最后一条指令之后）;如果出现无保护错误，则引发异常。在正常终止的情况下，`coroutine.resume`返回true，以及协程里main函数返回的任何值。如果出现错误，`coroutine.resume`将返回false加上错误对象。

通过调用`coroutine.yield`来获得协程。当协程生成时，相应的`coroutine.resume`立即返回，即使在嵌套函数调用内发生了收益（也就是说，不在main函数中，而是在main函数直接或间接调用的函数中）。在yield的情况下，`coroutine.resume`也返回true，加上传递给`coroutine.yield`的任何值。下次你恢复相同的协程时，它会从它产生的点继续执行，并调用`coroutine.yield`返回传递给`coroutine.resume的`任何额外参数。

与`coroutine.create`一样，`coroutine.wrap`函数也会创建一个协程，但它不会返回协程本身，而是返回一个函数，当调用它时，它会恢复协程。传递给此函数的任何参数都作为`coroutine.resume`的额外参数。`coroutine.wrap`返回`coroutine.resume`返回的所有值，第一个除外（布尔错误代码）。与`coroutine.resume`不同，`coroutine.wrap`不会捕获错误；任何错误都会传给调用者。

```lua
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
     
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
```

Output:

```
     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
```

也可以创建与操纵协程通过C的API：见`lua_newthread`, `lua_resume`和`lua_yield`
