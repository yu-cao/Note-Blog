## Lua 学习笔记

Lua作为一门动态语言，变量没有类型，但是值是有类型的，所有的值只能携带自己的类型

Lua中值是一等公民，所有的值都能被存储到变量中，作为参数传入函数，或者作为返回值返回

8种基本类型：

+ `nil`：通常表示某个变量是否有效
+ `boolean`：true/false。false和nil会使得条件判断为false，其余的值都是true
+ `number`：int和浮点数。有两个内部类型，int和float；尽管对何时使用某种类型有标准，但是它们是可以内部转换的，一般可以忽略这个问题。默认是64位int/float
+ `string`：不可变的字节序列。是以8位结算的，字符串可以包含任何8位的值，包括`\0`。Lua没有假设字符串中的内容
+ `function`：Lua可以调用（和操作）用Lua编写的函数和用C编写的函数。两者都由`function`表示。
+ `userdata`：允许任意C数据存储在Lua变量中。 userdata值表示原始内存块。有两种userdata：full userdata（一个由Lua管理的内存块的对象）和light userdata（只是一个C指针值）。Userdata在Lua中没有预定义的操作，除非是赋值和identity test。通过使用`metatable`，程序员可以定义对于full userdata值的操作。只能通过C API在Lua中创建或修改Userdata值。这保证了主机程序拥有的数据的完整性。
+ `thread`：表示独立的执行线程，它用于实现协程。Lua线程与操作系统线程无关。Lua支持所有系统上的协同程序，甚至是那些本身不支持线程的协同程序。
+ `table`：用来实现关联数组，不仅可以包含数字作为索引的数组，也可以包含除nil和NaN外的任何值。表可以是异构的；也就是说，它们可以包含所有类型的值（除了nil）。值为nil的任何键都不被视为表的一部分。相反，任何不属于表的键都具有关联值nil。

表是Lua中唯一的数据结构机制：它们可用于表示普通数组，链表，符号表，集合，record，图，树等。为了表示记录，Lua使用字段名称作为索引。该语言通过提供`a.name`作为`a["name"]`的语法糖来支持此表示

与索引一样，table字段的值可以是任何类型。特别是，因为函数是第一类值，所以table字段可以包含函数。因此，table也可以带有方法

表的索引遵循语言中原始相等的定义。表达式a[i]和a[j]表示相同的表元素当且仅当i和j是原始相等时（即equal without metamethods）。特别地，具有整数值的浮点数等于它们各自的整数（例如，1.0 == 1）。为避免歧义，任何具有用作键的整数值的浮点数都将转换为其各自的整数。例如，如果你写一个[2.0] = true，插入表中的实际key将是整数2，value为true.（另一方面，`2`和`"2"`是不同的Lua值，因此表示不同的表项。）

表，函数，线程和（full）用户数据值是对象：**变量实际上不包含这些值，只是对它们的引用。**赋值，参数传递和函数返回总是操纵对这些值的**引用**

库函数`type`返回一个字符串来描述一个给定值的类型

### 环境与全局环境

对于自由名称（没有绑定到任何声明上的名称）`var`的任何引用语法都会被翻译为`_ENV.var`。此外，每个chunk都会在名为`_ENV`的外部局部变量范围内编译。因此`_ENV`在chunk内部自身并不是一个自由的名称

尽管存在这个外部`_ENV`变量和自由名称的翻译，但是事实上`_ENV`完全就是一个普通的名称。特别地，你可以用那个名字定义一个新的变量或参数。每个对于自由名称的引用都是用在该点可见的`_ENV`，这遵循Lua的usual visibility rule

用作_ENV值的任何table都称为环境（environment）

Lua保持这一个特别的环境，称为全局环境。这个值保持在一个C注册表中的特别的索引处。在Lua中，全局变量`_G`被初始化为相同的值（`_G`不会被内部使用）

当Lua加载一个块时，其`_ENV` upvalue的默认值是全局环境。因此，默认情况下，Lua代码中的自由名称是指全局环境中的条目（因此，它们也称为全局变量）。此外，所有标准库都加载到全局环境中，并且一些功能在该全局环境中运行。我们可以使用load（或loadfile）来加载具有不同环境的块。（在C中，您必须加载块（chunk），然后更改其第一个upvalue的值）
