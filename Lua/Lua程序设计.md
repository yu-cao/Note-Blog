## Lua程序设计学习笔记1

全局变量：全局变量无需声明即可使用，未经过初始化的全局变量结果是`nil`，当把`nil`赋值给全局变量时，Lua就会回收这个全局变量

userdata类型允许把任意的C语言数据保存到Lua变量中

`nil`的含义应该是为：无效值

条件语句中，除了`Boolean`值为`false`或者是`nil`之外，其他值都是`true`，注意：**零和空字符串也视为真**

`and`、`or`和`not`

对于`and`，如果第一个操作数为真，则返回后面一个操作数，对于`or`，如果第一个操作数不为假，则返回第一个操作数（也就是短路法则）

这里，用`x = x or v`这个语法等价于`if not x then x = v end`（若x未被初始化，则x初始化为v）

`not`永远返回一个`Boolean`值

Lua的数据格式为64位的*integer*和称为*float*的**双精度**浮点类型，具有相同算术值的整型和浮点型在Lua中是相等的，Lua还支持十六进制的浮点数，这种浮点数由小数部分和以p/P开头的指数部分组成：

```lua
>0x0.2 -->0.125
>0x1p-1 -->0.5
>0xa.bp2 -->42.75
```

Lua支持取整除法（floor除法），取模和指数运算。格言：**要么忽略所有的整型与浮点数之间的不同，要么就完整地控制每个数值的表示**

除法运算的操作永远保证是浮点数，Lua 5.3支持*floor除法*，运算符为`//`，对得到的商向着负无穷取整：

```lua
> 3.0 // 2 --> 1.0
> -9 // 2 --> -5
```

取模：对于整数的取模，符号永远与第二个操作数保持一致，对于实数的取模，运算有点不同，例如，`x-x%0.01`恰好保留x的两位小数

```lua
> x = math.pi
> x - x % 0.01 -->3.14
> x - x % 0.001 -->3.141
```

Lua语言也支持幂运算，用符号`^`表示，其操作数也永远是浮点数类型

比较数值时应该永远忽略数值的类型，而只是比较算术值

`math.random`生成伪随机数，有3种方式，不带参数返回[0,1)，带**整数参数**返回一个[1, n]范围内的伪随机**整数**，当存在两个**整型值l和u**的参数调用时，该函数返回[l, u]返回内的伪随机**整数**

函数`randomseed`用于设置伪随机数发生器的种子，唯一参数就是数值类型的种子。如果我们不想某个游戏场景一遍又一遍重现，通常调用`math.randomseed(os.time())`来根据当前系统时间作为种子

数学库的3个取整函数：`floor`（向负无穷取整），`ceil`（向正无穷取整）和`modf`（向0取整，此外还会返回小数部分作为第二个结果，Lua的函数是多返回的）

在Lua中，超过整数的上限（`math.maxinteger`）或者下限（`math.mininteger`），这个行为是一致且可预测的：

```lua
> math.maxinteger + 1 == math.mininteger -->true
> math.mininteger - 1 == math.maxinteger -->true
> -math.mininteger == math.mininteger -->true
```

标准Lua使用64-bit来存储整型；精简Lua使用32-bit来存储整型，超过会发生回环

```lua
> math.maxinteger + 2   --> -9223372036854775807
> math.maxinteger + 2.0 --> 9.2233720368548e+18
```

上面两个在数学上都是错误的，第一个是发生了回环，第二个是被取整成为了一个近似值，也即：

```lua
> math.maxinteger + 2.0 == math.maxinteger + 1.0 -->true
```

浮点表示[-2^53, 2^53]之间，如果超过这个，将会发生精度损失：

```lua
> 9007199254740993 + 0.0 == 9007199254740993 -->false
```

**Trick：**通过与0按位**或**操作可以将浮点值转换成为整型值：

```lua
> 2^53 -->9.007199254741e+15
> 2^53 | 0 -->9007199254740992
```

当然，可以使用`math.tointeger`函数转换