##Haskell入门笔记1

学习资料为《Haskell Book》

与图灵机一样，lambda演算规范化了有效可计算性的概念，lambda演算与图灵机等价，Haskell正是基于lambda演算的基础之上的。

函数式编程的本质是程序是表达式(expressions)的组合，表达式包括具体值，变量与函数。

在Haskell中，函数是一等公民(first-class)，我们可以使用函数作为值或者作为参数或者输入，来传递给更多函数

函数式编程中的单词：“纯度”(purity)有时也用于表示“引用透明性”(referential transparency)。引用透明性意味着，给定相同的值进行评估时，相同的函数将始终在纯函数式编程中返回相同的结果，就像在数学中一样。(一一映射关系）

那么什么是函数？我们给出以下定义：假如`f(1) = A`，那么只要函数的输入值为1，输出值必定为A，没有例外！

<hr>

lambda表达式结构

分为3个部分，分别为表达式(expressions), 变量(variables)和抽象(abstractions)

表达式是以下所有东西的超集：变量名，抽象，或者这些东西的组合。最简单的表达式只有一个单变量。要注意，这里的变量并不意味着值(value)，只是函数潜在输入的名字

一个抽象就是一个函数。一个lambda表达式有一个头(&lambda;)和函数体，并且应用于参数（也就是输入值）

抽象由两部分组成：头部和身体。函数的头部是&lambda;，后跟变量名。函数的主体是另一个表达式。所以，一个简单的函数可能如下所示：

&lambda;x.x

这里在头部被命名的变量是参数(parameter)，并绑定(bind)函数体中同一变量的所有实例。

注意这里和我们传统的`y = f(x)`函数的区别，这个函数是一个匿名函数(anonymous function)，匿名函数是无法被另一个函数按名称调用。

上面的表达式中，点(dot)的作用是分隔开lambda的参数与函数体。

<hr>

&alpha;-等价(Alpha equivalence)

就像我们的函数可以写作`f(x) = x`，`f(y) = y`一样，显然上面的这两个函数是等价的。自然地，同理可得&lambda;x.x与&lambda;y.y是等价的

&beta;-缩减(Beta reduction)

当我们将函数应用于参数时，我们将输入表达式替换为抽象体内的所有绑定变量实例。你也消除了抽象的头部，因为它的唯一目的是绑定一个变量。这个过程称为beta缩减。（简单来说就是把变量传进函数进行了实例化呗...）

以上面的函数为例：(&lambda;𝑥.𝑥)2 &rArr; 2，也就是说，原来的函数式`f(x) = x`，现在把参数x用变量2进行传入替换，于是最后返回结果是2（只不过lambda是匿名的，而f函数不是）

我们还可以将我们的身份函数应用于另一个lambda抽象，如下：

(&lambda;x.x)(&lambda;y.y)

在这种情况下，我们将整个抽象替换为x。我们将在这里使用一个新的语法[x:=z]来表示z将替换所有出现的x（这里z是函数&lambda;y.y）。我们像这样减少这个应用程序：

(&lambda;x.x)(&lambda;y.y)  （[x :=(&lambda;y.y)]）&rArr; &lambda;y.y

我们最后得到的结果是另一个身份函数，这个函数没有参数去应用，所以我们无法对其再进行化简了

接下来我们用这个稍微更复杂的例子：

(&lambda;x.x)(&lambda;y.y)z

在lambda演算中的操作是左联的，也就是说除非有括号提升优先级，否则都是与左侧的相互关联或者组合，所以上式可以写成

((&lambda;x.x)(&lambda;y.y))z

持续使用&beta;-缩减可以得到

((&lambda;x.x)(&lambda;y.y))z  （[x :=(&lambda;y.y)]）&rArr; (&lambda;y.y)z  （[y:=z]）&rArr; z

也就是说，当没有更多的头或lambda，或者没有更多的参数来应用函数时，beta减少的过程就会停止。因此，计算由一个初始的lambda表达式（或两个，如果你想分离函数及其输入）加上一个有限的lambda术语序列组成，每个术语由前一个术语推导出一个beta减少的应用。我们一直遵循应用规则，用参数替换绑定变量，直到没有更多的头来评估或没有更多的参数来应用它们。

<hr>

自由变量

就像我们数学中函数出现`f(x) = xy`一样，x会在调用的时候实例化，但是y不会，也就是说，这里，y就是一个自由变量，同理，我们也可以写出这样的表达式：

&lambda;x.xy

现在，我们具体回顾一下`:=`这个表达式的过程，进行理解：

(&lambda;x.xy)z

由左联规则也就是z作为实参传入代替形参x，即[x:=z]得到：

(&lambda;[x:=z].xy) &rArr; zy

此时我们已经没有额外的信息支持化简了，所以zy就是最简式

注意，&alpha;-等价对于自由变量是不成立的，也就是说，&lambda;x.xy和&lambda;x.xz是不一样的

<hr>

多参数

每个lambda只能绑定一个参数，并且只能接受一个参数。需要多个参数的函数具有多个嵌套头。当你应用它一次并消除第一个（最左边）头部后，才能应用下一个头部，依此类推。

也就是说，&lambda;xy.xy 等价于 &lambda;x.(&lambda;y.xy)，在具体使用时先绑定x，对外面进行消除，再绑定y进行&lambda;y.xy函数（此时，x已经被外界参数绑定下来了）

例如我们有如下例子进行：

1. (𝜆𝑥𝑦.𝑥𝑦)(𝜆𝑧.𝑎) 1
2. (𝜆𝑥(𝜆𝑦.𝑥𝑦))(𝜆𝑧.𝑎) 1
3. [𝑥 ∶= (𝜆𝑧.𝑎)]
4. (𝜆𝑦.(𝜆𝑧.𝑎)𝑦) 1
5. [𝑦 ∶= 1]
6. (𝜆𝑧.𝑎) 1 （这里再次应用一下进行传入）
7. [𝑧 ∶= 1]
8. 𝑎 （因为函数与z无关，也就是类似f(z) = a，所以结果为a）

<hr>

评估就是简化(Evaluation is simplification)

在lambda演算中有多种常规形式，但是当我们提到标准形式(normal form)时，我们指的是β-标准形式(beta normal form)。 β-标准形式是指你无法进一步降低beta（将lambdas应用于参数）。这对应于完全被评估的表达式，或者在编程中对应于完全执行的程序。知道这一点非常重要，因为这样你就可以知道何时完成了对表达式的评估。当你获得Haskell代码时，对评估作为一种简化形式的评价也是有价值的。

比如说，你可以吧(10 + 2) * 100 / 2评估成为结果600，对于(&lambda;x,x)z来说，评估结果是z。

<hr>

组合器(Combinators)

组合器就是一个没有自由变量的lambda项。组合器只应用于组合他们给予的参数。

例如以下：

1. &lambda;x.x （x是唯一变量且受到约束因为它被约束在封闭的lambda中）
2. &lambda;xy.x
3. &lambda;xyz.xz(yz)

以下就不是组合器，因为存在大于等于1个的自由变量

1. &lambda;y.x （y是被约束的，但是x是自由的）
2. &lambda;x.xz （z是自由变量）

组合器的核心就是调出一个特殊的lambda表达式类，它只能组合给出的参数，而不会注入任何新值或随机数据。

<hr>

分歧(Divergence)

并非所有可简化的lambda项都能够整齐地降低为β标准形式。这并不意味着他们已经化简到最简形式了，而是因为它们有所不同。而这些分歧导致了整个β化简永远不会结束，而不会收敛。下面就是一个例子（我们称这种lambda类型为omega）：

1. (&lambda;x.xx)(&lambda;x.xx) 在第一个lambda头部的x成为了第二个lambda（也就是第一个自变量x被第二个lambda作为实参初始化了...）
2. ([x:=(λx.xx)]xx) 对x进行绑定
3. (&lambda;x.xx)(&lambda;x.xx) 进入替换之后发现，它又回到了(1)中的情况