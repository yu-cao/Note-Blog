<h2>Game Engine Architecture笔记</h2>

这里记录的只是我认为比较重要的，我认为我已经熟练掌握了的不再记录，如想要全面了解，请购买正版实体图书 https://book.douban.com/subject/25815142/

<h3>Chapter 2 专业工具</h3>

1. 预处理器设置：所有现在的C++预处理器可以通过命令行的方式定义预处理宏，使得通过生成选项控制代码，而不需要重新修改代码本身<br>
2. 在调试生成时，通常会通过关闭优化的方式进行，通常也会关闭内联函数

典型的生成配置为Debug版、Release版、Production版（或者叫Final版）其中，release版是依然保留着调试信息并且开启断言的，只有Production版才会完全开启优化并且关上断言

可以通过自己编写make这种基于文本的生成工具生成混合生成版本(hybrid build)加快速率，即大部分单元是Release模式，要调试的部分是Debug模式

注意，有些时候Release模式甚至Production模式下的bug可能无法在Debug模式中复现，有可能是未初始化变量造成，有可能是一些关键代码被错误地放入了断言中，也可能是数据结构的大小或者打包方式在不同模式下出现区别，导致在内联或者编译器优化时引入bug，极端罕见的情况是编译器自身的bug（可能性从前向后依次递减）

主要的**调试发布版**的方法：

1. 因为现在的架构导致优化后不可避免的指令乱序的情况，学会单步执行反汇编是基本功
2. 通过监视寄存器去推理变量：当调试器不能再发布版中正确显示变量的值或对象内容时，如果变量初次使用距离不远，很可能变量还在寄存器里，可以监测寄存器的方式进行跟踪
3. 修改源代码：加入打印语句帮助解决问题

<h3>Chapter 3 游戏软件工程基础</h3>

**避免使用多重继承**，不然可能会造成菱形继承问题（Diamond_problem）

多态：容许采用单一接共同接口操作一组不同类型的对象/使得异质的对象集合从接口代码上变得统一

编码规范：需要着重注意接口为王（让.h文件整洁、简单、短小、易于理解并有良好注释）和显露错误（Making Wrong Code Look Wrong）这两点

基本数据类型根据平台不同是不确定的，当一定需要一个确定的数据类型时，可以通过`__int8`、`__int16`等进行声明

SIMD类型：single instruction，multiple data
游戏编程中最常见的是把4个32位IEEE-754的浮点数打包，存进一个128位的SIMD寄存器（即float4类型），所以，即使你在申明时使用的是float2 or float3很可能实际硬件实现时依然以float4方式进行

头文件内的定义与内联：

1. 对一般的函数，禁止把定义置于头文件中，很容易会导致“多重定义错误”
2. 对于内联函数，必要要把内联函数置于头文件中以供多于一个翻译文件使用，因为编译器必须“看见”函数主体才能够把函数内联，即将每个调用内联函数的地方都会复制该函数的机器码并把机器码直接嵌入调用方的函数中

```Cpp
//foo.h
//Correct Use
inline int max(int a, int b)
{
    return (a > b) ? a : b;
}

//Wrong Use
//因为编辑器实质上“看不到”min()的主体，导致min()只能在foo.cpp中内联，无法影响其他的调用该函数的.cpp文件
//foo.h
inline int min(int a, int b);

//foo.cpp
int min(int a, int b)
{
    return (a <= b) ? a : b;
}
```

C/C++内存布局：

1. 映像(image)文件：

    * 代码段：程序中的全部函数的可执行机器码
    * 数据段：全部**获初始化**的全局与静态变量
    * BSS段(block started by symbol, BSS)：程序中定义的所有未初始化的全局变量与静态变量。C/C++明确定义，任何未初始化的全局变量与静态变量值皆为零

    ```Cpp
    //foo.cpp
    //F32 32位IEEE-754浮点数
    F32 gInitializedGlobal = -2.0f;//储存在数据段中，已经被初始化
    F32 gUnInitializedGlobal;//未被初始化，存在BSS段中，按BSS规则，操作系统为其分配空间并且初始化为0
    ```
    * 只读数据段：包含程序中定义的只读（常量）全局变量，整数常量可能直接占用代码段的储存空间，而不储存在只读数据段中

2. 程序堆栈

    * 堆栈帧储存数据三类数据，从高到底分别是以下内容：

        + 调用函数的返回地址
        + 相关CPU寄存器的内容。当函数返回之后，各个寄存器会还原至调用方原来的状态，如果有返回值，会存在特殊的用于保存返回值的寄存器中
        + 函数中的所有局部变量

3. 对象内存布局

    * 对齐与包裹
    
    ```cpp
    struct InefficientPacking
    {
        U32   mU1; //32bit
        F32   mF2; //32bit
        U8    mB3; // 8bit
        I32   mI4; //32bit
        bool  mB5; // 8bit
        char* mP6; //32bit
    }

    //节约了空间
    struct MoreEfficientPacking
    {
        U32   mU1; //32bit(4byte对齐)
        F32   mF2; //32bit(4byte对齐)
        I32   mI4; //32bit(4byte对齐)
        char* mP6; //32bit(4byte对齐)
        U8    mB3; // 8bit(1byte对齐)
        bool  mB5; // 8bit(1byte对齐)
    }

    struct BestPacking
    {
        U32   mU1;    //32bit(4byte对齐)
        F32   mF2;    //32bit(4byte对齐)
        I32   mI4;    //32bit(4byte对齐)
        char* mP6;    //32bit(4byte对齐)
        U8    mB3;    // 8bit(1byte对齐)
        bool  mB5;    // 8bit(1byte对齐)
        U8    _pad[2];//明确的填充让空间更加清晰
    }
    ```
    
    * C++中类的布局

        + 虚函数：当类中含有/继承了一个或者多个虚函数，就会在类的布局最前端添加4字节（或者目标硬件中指针所需的字节数）作为**虚表指针(vpointer)**，指向**虚函数表(vtable)**
        + 虚函数表：每个类的虚函数表中，包含了该类*声明或继承而来*的所有虚函数指针，**每个含有虚函数的具体类都有一个虚函数表**，并且这些类的实例都会有虚表指针指向该虚函数表

<h3>拓展：虚函数表</h3>

虚函数表是多态的核心，使得我们不再需要考虑代码是和那个具体类进行沟通

举例如下：

定义了Shape基类中有一个纯虚函数`Draw()`；`Circle`、`Rectangle`、`Triangle`都是派生类并且重载了此函数，提供了各自的实现

那么，任何继承了Shape的类，它的虚函数表中都会有Draw()这个函数的条目，只是这个条目的指向上会指向具体类中的函数实现入口

所以，如果我们有一个指针`Shape *pShape`，当我们把它指向一个Circle类，调用Draw：对Circle实例中的vpointer进行解引用，取得vtable，然后从表中找到Draw()进行调用，所以执行`Circle::Draw()`

这里再深入分析一下虚函数表与虚表指针：
        
当pShape指向了一个派生类实例，当我们调用`pShape->Draw()`时，虚表指针（注意，这个虚表指针是实例自身的）会解引用，得到该指针指向的内存地址的虚函数表（这个表中存在的都是指向一个个具体函数的指针）（也就是说`Shape *p = new Circle; p->Draw();`中，p解引用得到虚函数表示p所指向内存的那个，也就是Circle的虚函数表）

再从这个表中找到那个指向具体执行函数（因为是virtual，所以这个指针优先是指向在该类中具体重新实现的函数，当没有自己实现时，也就指向原先基类的函数作为继承，此时相当于virtual这个修饰词对这个派生类没有意义）的指针，然后根据这个指针进行具体的实现函数调用

错误的捕捉与处理

1. 用户错误：提示并继续运行
2. 开发者错误：让错误变得明显，并使得团队可在问题存在的情况下继续可以工作

    * 错误码
    * 异常：在游戏主机中效能有限，游戏引擎应该去完全关掉异常处理；但是在基于PC而开发的游戏引擎，可以尝试正常地使用异常处理的方式
    * 断言：开关断言可以依靠宏实现，十分方便。**注意：永远不要用断言捕捉用户错误，当断言失败，应该总是终止整个游戏程序！** 所以，断言应该用来捕捉严重错误，而失败后依然不是那么有影响的错误，不应该使用断言方式
